<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Chekkers</title>
    <link rel="icon" href="./asseets/images/boardfav.png" type="image/png" />
    <!-- bootstrap link -->
    <link
      href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css"
      rel="stylesheet"
    />
    <!-- font awsome-->
    <link
      rel="stylesheet"
      href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.6.0/css/all.min.css"
    />
    <!-- custom css -->
    <link rel="stylesheet" href="./asseets/css/style.css" />
    <style>
      .counter {
        display: flex;
        gap: 20px;
        /* background-color: #ecc59a; */
        padding: 10px 20px;
        border: 1px solid #ecc59a;
        border-radius: 5px;
      }

      .counter div {
        display: flex;
        align-items: center;
        gap: 10px;
      }

      #board {
        display: grid;
        grid-template-columns: repeat(8, 60px);
        grid-template-rows: repeat(8, 60px);
        margin: 0 auto;
        border: 2px solid #333;
        width: 480px;
        height: 480px;
        position: relative;
      }

      .cell {
        width: 60px;
        height: 60px;
        box-sizing: border-box;
        position: relative;
      }

      .black {
        background-color: #2a7ffe;
      }

      .white {
        background-color: #eeeed2;
      }

      .piece {
        width: 50px;
        height: 50px;
        border-radius: 50%;
        margin: 5px auto;
        position: absolute;
        top: 0;
        left: 4px;
        cursor: pointer;
        transition: transform 0.2s;
      }

      .red {
        background-color: white;
      }

      .black-piece {
        background-color: black;
      }

      .king {
        border: 2px solid gold;
      }

      .selected {
        outline: 3px solid yellow;
      }

      .highlight {
        background-color: rgba(255, 255, 0, 0.5);
        cursor: pointer;
      }

      #status {
        margin-top: 20px;
        font-size: 1.2em;
      }

      button,
      select {
        padding: 10px 20px;
        font-size: 1em;
        cursor: pointer;
      }

      @media (max-width: 768px) {
        #board {
          display: grid;
          grid-template-columns: repeat(8, 43px);
          grid-template-rows: repeat(8, 47px);
          margin: 0 auto;
          border: 2px solid #333;
          width: 100%;
          height: 350px;
          position: relative;
        }

        .cell {
          width: 47px;
          height: 47px;
          box-sizing: border-box;
          position: relative;
        }

        .piece {
          width: 30px;
          height: 30px;
          border-radius: 50%;
          margin: 5px auto;
          position: absolute;
          top: 4px;
          left: 7px;
          cursor: pointer;
          transition: transform 0.2s;
        }
      }

      @media (max-width: 576px) {
        .layout-main {
          padding: 0;
        }
      }
    </style>
  </head>

  <body class="">
    <!-- main layout -->
    <div class="layout-wrapper">
      <!-- sidebar -->
      <div class="layout-sidebar" id="sidebar">
        <button
          class="btn btn-round btn-primary d-block ms-auto"
          id="btnSideMobile"
        >
          <i class="fa-solid fa-xmark"></i>
        </button>
        <div class="layout-sidebar-header">
          <a href="./dashboard.html" class="text-decoration-none">
            <img
              class="img-fluid"
              src="./asseets/images/checkersx-logo-white.png"
              alt=""
            />
            <p class="fs-10 text-logo fontInter">
              Play Checkers Online on the #1 Site!
            </p>
          </a>
        </div>
        <div class="menu">
          <ul class="p-0">
            <li>
              <a href="./dashboard.html" class="px-3 py-2">
                <img src="./asseets/images/home.png" alt="" class="me-2" />
                Dasboard
              </a>
            </li>
            <li>
              <a href="./play.html" class="px-3 py-2">
                <img src="./asseets/images/board.svg" alt="" class="me-2" />
                Play
              </a>
            </li>
            <li>
              <a href="./tournament.html" class="px-3 py-2">
                <img src="./asseets/images/trophy.png" alt="" class="me-2" />
                Tournaments
              </a>
            </li>
            <li>
              <a href="./puzzle.html" class="px-3 py-2">
                <img src="./asseets/images/puzzle.png" alt="" class="me-2" />
                Puzzles
              </a>
            </li>
            <li>
              <a href="./learn.html" class="px-3 py-2">
                <img src="./asseets/images/learn.png" alt="" class="me-2" />
                Learn
              </a>
            </li>
            <li>
              <a href="./social.html" class="px-3 py-2">
                <img src="./asseets/images/social.png" alt="" class="me-2" />
                Social
              </a>
            </li>
            <li>
              <a href="./leatherboard.html" class="px-3 py-2">
                <img
                  src="./asseets/images/leaderboard.png"
                  alt=""
                  class="me-2"
                />
                Leatherboard
              </a>
            </li>
            <li>
              <a href="./profile.html" class="px-3 py-2">
                <img src="./asseets/images/profile.png" alt="" class="me-2" />
                Profile
              </a>
            </li>
            <li>
              <a
                href="https://docs.google.com/forms/d/e/1FAIpQLSeqPz62bjSipBR5zwJfNCRswsfZUiR4o0EOWD5KiLgmCgQNlw/viewform?embedded=true"
                class="px-3 py-2"
              >
                <img src="./asseets/images/support.png" alt="" class="me-2" />
                Support
              </a>
            </li>
            <li>
              <a href="./setting.html" class="px-3 py-2">
                <img src="./asseets/images/setting.png" alt="" class="me-2" />
                Setting
              </a>
            </li>
            <li>
              <a href="../login.html" class="px-3 py-2">
                <img src="./asseets/images/logout.png" alt="" class="me-2" />
                Logout
              </a>
            </li>
            <li>
              <div class="accordion" id="accordionExample">
                <div class="accordion-item">
                  <h2 class="accordion-header">
                    <button
                      class="accordion-button"
                      type="button"
                      data-bs-toggle="collapse"
                      data-bs-target="#collapseOne"
                      aria-expanded="true"
                      aria-controls="collapseOne"
                    >
                      <img src="./asseets/images/admin-profile.png" alt="" />
                      Admin
                    </button>
                  </h2>
                  <div
                    id="collapseOne"
                    class="accordion-collapse collapse"
                    data-bs-parent="#accordionExample"
                  >
                    <div class="accordion-body menu">
                      <ul class="p-0">
                        <li>
                          <a href="./updatelearn.html" class="px-3 py-2">
                            Update Learn
                          </a>
                        </li>
                        <li>
                          <a href="./updatenews.html" class="px-3 py-2">
                            Update News
                          </a>
                        </li>
                        <li>
                          <a href="./users.html" class="px-3 py-2"> Users </a>
                        </li>
                        <li>
                          <a href="./createtournamnet.html" class="px-3 py-2">
                            Create Tournamnet
                          </a>
                        </li>
                      </ul>
                    </div>
                  </div>
                </div>
              </div>
            </li>
          </ul>
        </div>
      </div>
      <!-- mian container -->
      <div class="layout-main-container" id="mainContainer">
        <!-- top header -->
        <div class="layout-topbar">
          <!-- button for toggle side bar -->
          <button class="btn btn-round btn-primary" id="btnSideBar">
            <i class="fa-solid fa-bars"></i>
          </button>
        </div>
        <!-- main layout -->
        <div class="layout-main">
          <div class="container">
            <!-- main play -->
            <div class="d-flex flex-wrap gap-3">
              <!-- play area -->

              <div class="d-flex flex-column gap-3 board-container">
                <div class="next-player counter text-white border-0 d-none">
                  Trun
                  <div class="occupied whitePiece" id="next-player"></div>
                </div>
                <!-- opponant -->
                <div class="d-flex justify-content-between">
                  <div class="d-flex align-items-center gap-2">
                    <img
                      src="./asseets/images/avatar.jpg"
                      alt=""
                      width="35px"
                      class="avaImage"
                    />
                    <p class="text-white ptitle m-0 fontInter">Opponents</p>
                  </div>
                  <div class="d-flex align-items-center gap-3">
                    <span
                      class="text-white clr-title"
                      id="black-player-count-pieces"
                      >0</span
                    >
                  </div>
                </div>
                <div id="controls"></div>

                <div id="board"></div>
                <div id="status">Select game mode to start</div>

                <div class="">
                  <div id="easyModal" class="modal">
                    <div class="modal-content">
                      <div class="modal-body">
                        <p>
                          The <strong id="winner"></strong> player won the game
                          !!
                        </p>
                        <p>
                          <span id="loser"></span>, whould you take your revenge
                          ???
                        </p>

                        <div class="btn-container">
                          <button class="btn" onclick="location.reload()">
                            Yes
                          </button>
                          <button class="btn" onclick="modalClose()">No</button>
                        </div>
                      </div>
                    </div>
                  </div>
                  <div class="game" id="game"></div>
                  <!-- <div class="counter text-white">
                    <div>
                      <div class="occupied whitePiece"></div>
                      <span id="white-player-count-pieces">0</span>
                    </div>
                    <div>
                      <div class="occupied blackPiece"></div>
                      <span id="black-player-count-pieces">0</span>
                    </div>
                  </div> -->
                </div>
                <!-- user -->
                <div class="d-flex justify-content-between">
                  <div class="d-flex align-items-center gap-2">
                    <img
                      src="./asseets/images/avatar.jpg"
                      alt=""
                      width="35px"
                      class="avaImage"
                    />
                    <p class="text-white ptitle m-0 fontInter">user</p>
                  </div>
                  <div class="d-flex align-items-center gap-3">
                    <!-- <p class="text-white clr-title">10</p> -->
                    <span
                      class="text-white clr-title"
                      id="white-player-count-pieces"
                      >0</span
                    >
                  </div>
                </div>
              </div>
              <!-- setting area -->
              <div class="d-flex flex-column gap-3 mobile-flex-grow-1">
                <div class="mt-5 pt-4">
                  <div
                    class="d-flex justify-content-between bg-white mainradio"
                  >
                    <!-- Button group mimicking p-selectbutton -->
                    <div class="btn-radio first">
                      <input type="radio" id="min1" name="time" value="1" />
                      <label for="min1">1 Min</label>
                    </div>
                    <div class="btn-radio">
                      <input type="radio" id="min3" name="time" value="3" />
                      <label for="min3">3 Min</label>
                    </div>
                    <div class="btn-radio">
                      <input type="radio" id="min5" name="time" value="5" />
                      <label for="min5">5 Min</label>
                    </div>
                    <div class="btn-radio last">
                      <input type="radio" id="min10" name="time" value="10" />
                      <label for="min10">10 Min</label>
                    </div>
                  </div>

                  <div>
                    <label for="game-mode" class="text-white form-label"
                      >Select Game Mode:
                    </label>
                    <select class="form-control" id="game-mode">
                      <option value="single">Single Player (AI)</option>
                      <option value="multi">Multiplayer</option>
                    </select>
                  </div>
                  <div id="ai-controls">
                    <label class="form-label text-white" for="ai-difficulty"
                      >Select Difficulty:
                    </label>
                    <select id="ai-difficulty" class="form-control">
                      <option value="easy">Easy</option>
                      <option value="medium">Medium</option>
                      <option value="hard">Hard</option>
                    </select>
                  </div>
                  <div class="progress-container mt-2 d-flex gap-1 flex-column">
                    <i class="fa-solid fa-clock text-white"></i>
                    <div class="progress">
                      <div
                        class="progress-bar"
                        role="progressbar"
                        id="progress-bar"
                        aria-valuenow="0"
                        aria-valuemin="0"
                        aria-valuemax="100"
                      ></div>
                    </div>
                  </div>

                  <button
                    class="btn btn-primary w-100 fontInter b-rounded my-2"
                    id="restart-button"
                  >
                    Play
                  </button>
                  <!-- Progress Button -->
                  <!-- <button
                    class="btn btn-primary fontInter b-rounded my-2"
                    id="playBtn w-100"
                  >
                    Play
                  </button> -->

                  <div class="card flex-grow-1 my-2">
                    <div class="card-body p-3 d-flex align-items-center gap-3">
                      <img
                        src="./asseets/images/board.svg"
                        alt=""
                        width="50px"
                      />
                      <div>
                        <p class="clr-title text-black fontInter m-0">
                          8x8 Checkers
                        </p>
                        <p class="textLight fontInter f-14 m-0">
                          8x8 Checkers American Variant.
                        </p>
                      </div>
                    </div>
                  </div>
                  <div class="card flex-grow-1 my-2">
                    <div class="card-body p-3 d-flex align-items-center gap-3">
                      <img
                        src="./asseets/images//customegame.png"
                        alt=""
                        width="50px"
                      />
                      <div>
                        <p class="clr-title text-black fontInter m-0">
                          Custom Games
                        </p>
                        <p class="textLight fontInter f-14 m-0">
                          Find fun new ways to play.
                        </p>
                      </div>
                    </div>
                  </div>
                  <div class="card flex-grow-1 my-2">
                    <div class="card-body p-3 d-flex align-items-center gap-3">
                      <img
                        src="./asseets/images/playwithcomputer.png"
                        alt=""
                        width="50px"
                      />
                      <div>
                        <p class="clr-title text-black fontInter m-0">
                          Play Against Computer
                        </p>
                        <p class="textLight fontInter f-14 m-0">
                          Challenge bots from an Easy level to a Master Level.
                        </p>
                      </div>
                    </div>
                  </div>
                </div>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>
    <!-- bootstrap script -->
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/js/bootstrap.bundle.min.js"></script>
    <!-- jQuery CDN -->
    <script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>
    <!-- custom script -->
    <script src="../asseets/js/script.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/progressbar.js@1.0.1/dist/progressbar.min.js"></script>

    <script>
      // Constants
      const BOARD_SIZE = 8;
      const PLAYER_RED = "red";
      const PLAYER_BLACK = "black-piece"; // Updated to match CSS class

      // Game State
      let board = [];
      let selectedPiece = null;
      let currentPlayer = PLAYER_RED;
      let gameMode = "single"; // 'single' or 'multi'
      let aiDifficulty = "easy"; // 'easy', 'medium', 'hard'
      let isAIThinking = false; // To prevent multiple AI moves
      let mustContinueCapture = false; // Flag for multiple captures

      const progressBar = document.getElementById("progress-bar");
      let timer;
      const playButton = document.getElementById("restart-button");
      function startProgress(duration) {
        document.querySelectorAll(".piece").forEach((ele) => {
          ele.style.display = "block";
        });
        let progress = 0;
        const interval = 100; // Update progress every 100ms
        const totalIntervals = (duration * 60 * 1000) / interval; // Calculate total intervals

        clearInterval(timer); // Clear any previous interval
        progressBar.style.width = "0%"; // Reset progress bar
        progressBar.setAttribute("aria-valuenow", 0);

        timer = setInterval(() => {
          progress++;
          const percentage = (progress / totalIntervals) * 100;
          progressBar.style.width = `${percentage}%`;
          progressBar.setAttribute("aria-valuenow", percentage);

          if (percentage >= 100) {
            clearInterval(timer);
            restartGame();
          }
        }, interval);
      }

      playButton.addEventListener("click", () => {
        const selectedTime = document.querySelector(
          'input[name="time"]:checked'
        );
        if (selectedTime) {
          const duration = parseInt(selectedTime.value);
          startProgress(duration);
        } else {
          alert("Please select a time duration!");
        }
      });
      // Initialize Board
      function initBoard() {
        board = [];
        for (let row = 0; row < BOARD_SIZE; row++) {
          let rowArray = [];
          for (let col = 0; col < BOARD_SIZE; col++) {
            if ((row + col) % 2 === 1) {
              if (row < 3) {
                rowArray.push({ player: PLAYER_BLACK, isKing: false });
              } else if (row > 4) {
                rowArray.push({ player: PLAYER_RED, isKing: false });
              } else {
                rowArray.push(null);
              }
            } else {
              rowArray.push(null);
            }
          }
          board.push(rowArray);
        }
      }

      // Render Board
      function renderBoard() {
        const boardDiv = document.getElementById("board");
        boardDiv.innerHTML = "";
        for (let row = 0; row < BOARD_SIZE; row++) {
          for (let col = 0; col < BOARD_SIZE; col++) {
            const cell = document.createElement("div");
            cell.classList.add("cell");
            cell.classList.add((row + col) % 2 === 0 ? "white" : "black");
            cell.dataset.row = row;
            cell.dataset.col = col;

            const piece = board[row][col];
            if (piece) {
              const pieceDiv = document.createElement("div");
              pieceDiv.classList.add("piece");
              pieceDiv.classList.add(
                piece.player === PLAYER_RED ? "red" : "black-piece"
              );
              if (piece.isKing) {
                pieceDiv.classList.add("king");
              }
              pieceDiv.dataset.row = row;
              pieceDiv.dataset.col = col;
              pieceDiv.addEventListener("click", onPieceClick);
              cell.appendChild(pieceDiv);
            }

            boardDiv.appendChild(cell);
          }
        }
      }

      // Handle Piece Click
      function onPieceClick(event) {
        const clickSound = new Audio("./asseets/sound/268161105_nw_prev.m4a");
        if (isAIThinking) return; // Prevent interaction during AI's turn

        if (gameMode === "single" && currentPlayer !== PLAYER_RED) return; // Only player can move in single mode

        const row = parseInt(event.target.dataset.row);
        const col = parseInt(event.target.dataset.col);
        const piece = board[row][col];

        if (!piece || piece.player !== currentPlayer) return;
        clickSound.play();
        if (mustContinueCapture) {
          // If must continue capture, only allow moves for the selected piece
          if (
            selectedPiece &&
            (selectedPiece.row !== row || selectedPiece.col !== col)
          ) {
            return;
          }
        }

        if (
          selectedPiece &&
          selectedPiece.row === row &&
          selectedPiece.col === col
        ) {
          // Deselect if the same piece is clicked again
          clearSelection();
          return;
        }

        if (selectedPiece) {
          clearSelection();
          if (selectedPiece.row === row && selectedPiece.col === col) {
            return;
          }
        }

        selectedPiece = { row, col };
        highlightSelected(row, col);
        showValidMoves(row, col);
      }

      // Highlight Selected Piece
      function highlightSelected(row, col) {
        const boardDiv = document.getElementById("board");
        const index = row * BOARD_SIZE + col;
        const cell = boardDiv.children[index];
        cell.classList.add("selected");
      }

      // Clear Selection
      function clearSelection() {
        const boardDiv = document.getElementById("board");
        Array.from(boardDiv.children).forEach((cell) =>
          cell.classList.remove("selected", "highlight")
        );
        selectedPiece = null;
        renderBoard();
      }

      // Show Valid Moves
      function showValidMoves(row, col) {
        let moves = getValidMoves(row, col, board);

        // Enforce mandatory captures
        if (!mustContinueCapture) {
          const allMoves = getAllPossibleMoves(currentPlayer, board);
          const captureMoves = allMoves.filter((move) => move.capture);
          if (captureMoves.length > 0) {
            moves = moves.filter((move) => move.capture);
          }
        }

        if (moves.length === 0) {
          // No moves available for selected piece
          clearSelection();
          return;
        }

        const boardDiv = document.getElementById("board");
        moves.forEach((move) => {
          const [toRow, toCol] = move.to;
          const index = toRow * BOARD_SIZE + toCol;
          const cell = boardDiv.children[index];
          cell.classList.add("highlight");
          cell.addEventListener("click", () =>
            onMoveClick(row, col, toRow, toCol)
          );
        });
      }

      // Handle Move Click
      function onMoveClick(fromRow, fromCol, toRow, toCol) {
        makeMove(fromRow, fromCol, toRow, toCol);
        clearSelection();

        const move = {
          from: [fromRow, fromCol],
          to: [toRow, toCol],
          capture: Math.abs(toRow - fromRow) === 2,
        };

        if (move.capture) {
          // Check if another capture is possible with the moved piece
          const continuedMoves = getValidMoves(toRow, toCol, board).filter(
            (m) => m.capture
          );
          if (continuedMoves.length > 0) {
            selectedPiece = { row: toRow, col: toCol };
            mustContinueCapture = true;
            highlightSelected(toRow, toCol);
            showValidMoves(toRow, toCol);
            return;
          }
        }

        // Reset capture flag if no further captures
        mustContinueCapture = false;
        switchPlayer();
      }

      // Switch Player
      function switchPlayer() {
        if (gameMode === "multi") {
          currentPlayer =
            currentPlayer === PLAYER_RED ? PLAYER_BLACK : PLAYER_RED;
        } else if (gameMode === "single") {
          currentPlayer =
            currentPlayer === PLAYER_RED ? PLAYER_BLACK : PLAYER_RED;
        }
        updateStatus();
        if (gameMode === "single" && currentPlayer === PLAYER_BLACK) {
          setTimeout(() => {
            aiMove();
          }, 500);
        }
      }

      // Update Status
      function updateStatus() {
        const statusDiv = document.getElementById("status");
        if (gameMode === "single") {
          if (currentPlayer === PLAYER_RED) {
            statusDiv.textContent = "Your turn";
          } else {
            statusDiv.textContent = "AI's turn";
          }
        } else {
          statusDiv.textContent =
            currentPlayer === PLAYER_RED ? "Red's turn" : "Black's turn";
        }
      }

      // Make Move
      function makeMove(fromRow, fromCol, toRow, toCol) {
        const piece = board[fromRow][fromCol];
        board[toRow][toCol] = piece;
        board[fromRow][fromCol] = null;

        // King Me
        if (piece.player === PLAYER_RED && toRow === 0 && !piece.isKing) {
          piece.isKing = true;
        }
        if (
          piece.player === PLAYER_BLACK &&
          toRow === BOARD_SIZE - 1 &&
          !piece.isKing
        ) {
          piece.isKing = true;
        }

        // Capture
        if (Math.abs(toRow - fromRow) === 2) {
          const capturedRow = (fromRow + toRow) / 2;
          const capturedCol = (fromCol + toCol) / 2;
          board[capturedRow][capturedCol] = null;
        }

        renderBoard();
        checkGameOver();
      }

      // Check Game Over
      function checkGameOver() {
        const playerRedPieces = countPieces(PLAYER_RED);
        const playerBlackPieces = countPieces(PLAYER_BLACK);
        let blackplayercount = document.getElementById(
          "black-player-count-pieces"
        );
        let whiteplayercount = document.getElementById(
          "white-player-count-pieces"
        );
        blackplayercount.innerText = playerBlackPieces;
        whiteplayercount.innerText = playerRedPieces;
        if (playerRedPieces === 0) {
          alert("Black wins!");
          restartGame();
        } else if (playerBlackPieces === 0) {
          alert("Red wins!");
          restartGame();
        }
      }

      // Count Pieces
      function countPieces(player) {
        let count = 0;
        for (let row = 0; row < BOARD_SIZE; row++) {
          for (let col = 0; col < BOARD_SIZE; col++) {
            const piece = board[row][col];
            if (piece && piece.player === player) {
              count++;
            }
          }
        }
        console.log("count ", count);
        return count;
      }

      // Get Valid Moves for a Piece with Board State
      function getValidMoves(row, col, boardState) {
        const piece = boardState[row][col];
        if (!piece) return [];

        const directions = [];
        if (piece.player === PLAYER_RED || piece.isKing) {
          directions.push([-1, -1]);
          directions.push([-1, 1]);
        }
        if (piece.player === PLAYER_BLACK || piece.isKing) {
          directions.push([1, -1]);
          directions.push([1, 1]);
        }

        const moves = [];
        directions.forEach((direction) => {
          const [dr, dc] = direction;
          const newRow = row + dr;
          const newCol = col + dc;
          if (isInside(newRow, newCol) && !boardState[newRow][newCol]) {
            // Regular move
            moves.push({
              from: [row, col],
              to: [newRow, newCol],
              capture: false,
            });
          } else if (
            isInside(newRow, newCol) &&
            boardState[newRow][newCol]?.player !== piece.player
          ) {
            const jumpRow = newRow + dr;
            const jumpCol = newCol + dc;
            if (isInside(jumpRow, jumpCol) && !boardState[jumpRow][jumpCol]) {
              // Capture move
              moves.push({
                from: [row, col],
                to: [jumpRow, jumpCol],
                capture: true,
              });
            }
          }
        });

        return moves;
      }

      // Check if position is inside the board
      function isInside(row, col) {
        return row >= 0 && row < BOARD_SIZE && col >= 0 && col < BOARD_SIZE;
      }

      // AI Move
      // function aiMove() {
      //   if (isAIThinking) return;
      //   isAIThinking = true;
      //   updateStatus();

      //   const aiMoves = getAllPossibleMoves(PLAYER_BLACK, board);
      //   if (aiMoves.length === 0) {
      //     alert("You win!");
      //     restartGame();
      //     isAIThinking = false;
      //     return;
      //   }

      //   let move;
      //   if (aiDifficulty === "easy") {
      //     move = randomMove(aiMoves);
      //   } else if (aiDifficulty === "medium") {
      //     move = minimaxMove(PLAYER_BLACK, 3); // Depth 3
      //   } else if (aiDifficulty === "hard") {
      //     move = alphabetaMove(PLAYER_BLACK, 5); // Depth 5
      //   }

      //   if (move) {
      //     makeMove(move.from[0], move.from[1], move.to[0], move.to[1]);

      //     // Check for multiple captures
      //     if (move.capture) {
      //       const continuedMoves = getValidMoves(
      //         move.to[0],
      //         move.to[1],
      //         board
      //       ).filter((m) => m.capture);
      //       if (continuedMoves.length > 0) {
      //         selectedPiece = { row: move.to[0], col: move.to[1] };
      //         mustContinueCapture = true;
      //         highlightSelected(move.to[0], move.to[1]);
      //         showValidMoves(move.to[0], move.to[1]);
      //         isAIThinking = false;
      //         return;
      //       }
      //     }

      //     // Reset capture flag if no further captures
      //     mustContinueCapture = false;
      //     isAIThinking = false;
      //     switchPlayer();
      //   } else {
      //     alert("AI has no valid moves. You win!");
      //     restartGame();
      //     isAIThinking = false;
      //   }
      // }
      function aiMove() {
        const moves = getAllPossibleMoves(PLAYER_BLACK, board);
        let bestMove = chooseBestMove(moves);

        if (bestMove) {
          makeMoveOnBoard(board, bestMove);
          renderBoard();

          let furtherMoves = getCaptureMoves(
            board[bestMove.to[0]][bestMove.to[1]],
            bestMove.to[0],
            bestMove.to[1],
            board
          );

          while (furtherMoves.length > 0) {
            const nextMove = furtherMoves[0];
            makeMoveOnBoard(board, nextMove);
            renderBoard();

            furtherMoves = getCaptureMoves(
              board[nextMove.to[0]][nextMove.to[1]],
              nextMove.to[0],
              nextMove.to[1],
              board
            );
          }
        }

        // Switch turn back to the player
        currentPlayer = PLAYER_RED;
        updateStatus(); // Update the game status to reflect the current player's turn
        checkGameOver();
      }

      function chooseBestMove(moves) {
        let bestMove = null;
        let bestScore = -Infinity;

        for (const move of moves) {
          // Clone the board to evaluate the move
          const newBoard = cloneBoard(board);
          makeMoveOnBoard(newBoard, move);

          // Evaluate the board after the move
          const score = evaluateBoard(newBoard);

          // Update the best score and best move if this score is better
          if (score > bestScore) {
            bestScore = score;
            bestMove = move;
          }
        }

        return bestMove;
      }

      // Get All Possible Moves for a Player with Board State
      function getAllPossibleMoves(player, boardState) {
        let moves = [];
        for (let row = 0; row < BOARD_SIZE; row++) {
          for (let col = 0; col < BOARD_SIZE; col++) {
            const piece = boardState[row][col];
            if (piece && piece.player === player) {
              const pieceMoves = getValidMoves(row, col, boardState);
              moves = moves.concat(pieceMoves);
            }
          }
        }

        // Enforce mandatory captures
        const captureMoves = moves.filter((move) => move.capture);
        if (captureMoves.length > 0) {
          return captureMoves;
        }
        return moves;
      }

      // Random Move AI
      function randomMove(moves) {
        return moves[Math.floor(Math.random() * moves.length)];
      }

      // Minimax AI
      function minimaxMove(player, depth) {
        const clonedBoard = cloneBoard(board);
        const [bestScore, bestMove] = minimax(
          clonedBoard,
          depth,
          player,
          -Infinity,
          Infinity
        );
        return bestMove;
      }

      // Minimax Algorithm
      function minimax(boardState, depth, player, alpha, beta) {
        if (depth === 0) {
          return [evaluateBoard(boardState), null];
        }

        const moves = getAllPossibleMoves(player, boardState);
        if (moves.length === 0) {
          return [player === PLAYER_BLACK ? -1000 : 1000, null];
        }

        let bestMove = null;

        if (player === PLAYER_BLACK) {
          // Maximizing player
          let maxEval = -Infinity;
          for (const move of moves) {
            const newBoard = cloneBoard(boardState);
            makeMoveOnBoard(newBoard, move);
            const [evalScore] = minimax(
              newBoard,
              depth - 1,
              PLAYER_RED,
              alpha,
              beta
            );
            if (evalScore > maxEval) {
              maxEval = evalScore;
              bestMove = move;
            }
            alpha = Math.max(alpha, evalScore);
            if (beta <= alpha) break;
          }
          return [maxEval, bestMove];
        } else {
          // Minimizing player
          let minEval = Infinity;
          for (const move of moves) {
            const newBoard = cloneBoard(boardState);
            makeMoveOnBoard(newBoard, move);
            const [evalScore] = minimax(
              newBoard,
              depth - 1,
              PLAYER_BLACK,
              alpha,
              beta
            );
            if (evalScore < minEval) {
              minEval = evalScore;
              bestMove = move;
            }
            beta = Math.min(beta, evalScore);
            if (beta <= alpha) break;
          }
          return [minEval, bestMove];
        }
      }

      // Alpha-Beta Pruning AI
      function alphabetaMove(player, depth) {
        const clonedBoard = cloneBoard(board);
        const [bestScore, bestMove] = alphabeta(
          clonedBoard,
          depth,
          player,
          -Infinity,
          Infinity
        );
        return bestMove;
      }

      // Alpha-Beta Algorithm
      function alphabeta(boardState, depth, player, alpha, beta) {
        const moves = getAllPossibleMoves(player, boardState);
        if (moves.length === 0) {
          return [player === PLAYER_BLACK ? -1000 : 1000, null];
        }

        function hasMoreCaptures([row, col], boardState) {
          const piece = boardState[row][col];
          if (!piece) return false;

          const directions = [
            [-2, -2],
            [-2, 2],
            [2, -2],
            [2, 2], // Diagonal moves for capturing
          ];

          for (const [dr, dc] of directions) {
            const newRow = row + dr;
            const newCol = col + dc;

            if (
              newRow >= 0 &&
              newRow < BOARD_SIZE &&
              newCol >= 0 &&
              newCol < BOARD_SIZE &&
              boardState[newRow][newCol] === null
            ) {
              const capturedRow = row + dr / 2;
              const capturedCol = col + dc / 2;
              const capturedPiece = boardState[capturedRow][capturedCol];

              if (capturedPiece && capturedPiece.player !== piece.player) {
                return true; // More captures available
              }
            }
          }
          return false;
        }

        let bestMove = null;

        if (player === PLAYER_BLACK) {
          // Maximizing player
          let maxEval = -Infinity;
          for (const move of moves) {
            const newBoard = cloneBoard(boardState);
            const isCapture = makeMoveOnBoard(newBoard, move);

            let evalScore;
            if (isCapture && hasMoreCaptures(move.to, newBoard)) {
              // If a capture happened and more captures are possible, continue with the same piece
              [evalScore] = alphabeta(newBoard, depth - 1, player, alpha, beta);
            } else {
              // Regular evaluation with the next player's turn
              [evalScore] = alphabeta(
                newBoard,
                depth - 1,
                PLAYER_RED,
                alpha,
                beta
              );
            }

            if (evalScore > maxEval) {
              maxEval = evalScore;
              bestMove = move;
            }
            alpha = Math.max(alpha, evalScore);
            if (beta <= alpha) break;
          }
          return [maxEval, bestMove];
        } else {
          // Minimizing player
          let minEval = Infinity;
          for (const move of moves) {
            const newBoard = cloneBoard(boardState);
            const isCapture = makeMoveOnBoard(newBoard, move);

            let evalScore;
            if (isCapture && hasMoreCaptures(move.to, newBoard)) {
              // If a capture happened and more captures are possible, continue with the same piece
              [evalScore] = alphabeta(newBoard, depth - 1, player, alpha, beta);
            } else {
              // Regular evaluation with the next player's turn
              [evalScore] = alphabeta(
                newBoard,
                depth - 1,
                PLAYER_BLACK,
                alpha,
                beta
              );
            }

            if (evalScore < minEval) {
              minEval = evalScore;
              bestMove = move;
            }
            beta = Math.min(beta, evalScore);
            if (beta <= alpha) break;
          }
          return [minEval, bestMove];
        }
      }

      // Evaluate Board
      function evaluateBoard(boardState) {
        let score = 0;
        for (let row = 0; row < BOARD_SIZE; row++) {
          for (let col = 0; col < BOARD_SIZE; col++) {
            const piece = boardState[row][col];
            if (piece) {
              const value = piece.isKing ? 3 : 1;
              score += piece.player === PLAYER_BLACK ? value : -value;
            }
          }
        }
        return score;
      }

      // Clone Board
      function cloneBoard(boardState) {
        return boardState.map((row) =>
          row.map((cell) => (cell ? { ...cell } : null))
        );
      }

      // Make Move on Cloned Board
      // Make Move on Cloned Board
      function makeMoveOnBoard(boardState, move) {
        const [fromRow, fromCol] = move.from;
        const [toRow, toCol] = move.to;
        const piece = boardState[fromRow][fromCol];

        // Move the piece to the new position
        boardState[toRow][toCol] = piece;
        boardState[fromRow][fromCol] = null;

        // King the piece if it reaches the opposite end
        if (piece.player === PLAYER_RED && toRow === 0 && !piece.isKing) {
          piece.isKing = true;
        }
        if (
          piece.player === PLAYER_BLACK &&
          toRow === BOARD_SIZE - 1 &&
          !piece.isKing
        ) {
          piece.isKing = true;
        }

        // Handle Capture
        if (Math.abs(toRow - fromRow) === 2) {
          const capturedRow = (fromRow + toRow) / 2;
          const capturedCol = (fromCol + toCol) / 2;
          boardState[capturedRow][capturedCol] = null;

          // Check for further captures from the new position
          let furtherMoves = getCaptureMoves(piece, toRow, toCol, boardState);
          if (furtherMoves.length > 0) {
            // Perform the next capture automatically (AI continuation)
            makeMoveOnBoard(boardState, furtherMoves[0]); // Choose the first available capture
          }
        }
      }

      function getCaptureMoves(piece, row, col, boardState) {
        const directions = [
          [-2, -2],
          [-2, 2],
          [2, -2],
          [2, 2], // All diagonal jumps
        ];
        const captures = [];

        for (const [dRow, dCol] of directions) {
          const newRow = row + dRow;
          const newCol = col + dCol;

          // Ensure the move stays within board boundaries
          if (
            newRow >= 0 &&
            newRow < BOARD_SIZE &&
            newCol >= 0 &&
            newCol < BOARD_SIZE &&
            boardState[newRow][newCol] === null
          ) {
            const midRow = row + dRow / 2;
            const midCol = col + dCol / 2;
            const midPiece = boardState[midRow][midCol];

            // Check if there's an opponent piece to capture
            if (midPiece && midPiece.player !== piece.player) {
              captures.push({ from: [row, col], to: [newRow, newCol] });
            }
          }
        }
        return captures;
      }

      // Restart Game
      function restartGame() {
        initBoard();
        renderBoard();

        selectedPiece = null;
        currentPlayer = PLAYER_RED;
        mustContinueCapture = false;
        updateStatus();
        checkGameOver();
        if (gameMode === "single" && currentPlayer === PLAYER_BLACK) {
          setTimeout(() => {
            aiMove();
          }, 500);
        }
      }

      // Handle Game Mode Selection
      function handleGameModeSelection() {
        const modeSelector = document.getElementById("game-mode");
        gameMode = modeSelector.value;
        const aiControls = document.getElementById("ai-controls");
        if (gameMode === "single") {
          aiControls.style.display = "block";
          currentPlayer = PLAYER_RED;
          mustContinueCapture = false;
          updateStatus();
          if (currentPlayer === PLAYER_BLACK) {
            aiMove();
          }
        } else {
          aiControls.style.display = "none";
          currentPlayer = PLAYER_RED;
          mustContinueCapture = false;
          updateStatus();
        }
      }

      // Handle AI Difficulty Selection
      function handleAIDifficultySelection() {
        const difficultySelector = document.getElementById("ai-difficulty");
        aiDifficulty = difficultySelector.value;
      }

      // Attach Event Listeners
      document
        .getElementById("restart-button")
        .addEventListener("click", restartGame);
      document
        .getElementById("game-mode")
        .addEventListener("change", handleGameModeSelection);
      document
        .getElementById("ai-difficulty")
        .addEventListener("change", handleAIDifficultySelection);

      // Initialize Game on Load
      window.onload = () => {
        // initBoard();

        initBoard();
        renderBoard();
        handleGameModeSelection(); // To set initial state
        document.querySelectorAll(".piece").forEach((ele) => {
          ele.style.display = "none";
        });
      };
    </script>
  </body>
</html>
